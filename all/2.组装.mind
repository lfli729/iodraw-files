{"root":{"data":{"id":"d3ejy2qfdyio","created":1723528736084,"text":"2.组装"},"children":[{"data":{"id":"d3ekb9h8sl4w","created":1723529769500,"text":"Steps4.metagenome assembly\n step0: preparation【三代无】"},"children":[{"data":{"id":"d3ekbfe3vthc","created":1723529782371,"text":"调用脚本：metaG_main_pipeline/genome_assembly_preparation.py"},"children":[]},{"data":{"id":"d3ekbiely5mo","created":1723529788932,"text":"id: genome_assembly_preparation_cleanData"},"children":[]},{"data":{"id":"d3ekblbdbthc","created":1723529795266,"text":"脚本用途"},"children":[{"data":{"id":"d3ekbo5m0mww","created":1723529801449,"text":"1.读入去宿主后的fq序列，读入脚本配置文件获取seqkit的路径；"},"children":[]},{"data":{"id":"d3ekbsi7d0cg","created":1723529810917,"text":"2.使用seqkit stats统计每个fastq的总序列数、总碱基数、最长序列长度、最短序列长度、平均序列长度等。"},"children":[]},{"data":{"id":"d3ekbwn4w4xs","created":1723529819922,"text":"3.同时会在结果路径cleanData下生成cleanData.baseNum文件记录每个序列的碱基数目。"},"children":[]}]},{"data":{"id":"d3ekc13ah728","created":1723529829606,"text":"输出文件夹：genome_assembly_preparation_cleanData_*"},"children":[]},{"data":{"id":"d3ekc88as6bk","created":1723529845147,"text":"任务关联"},"children":[{"data":{"id":"d3ekc966fda8","created":1723529847195,"text":"上级任务data_process_rmhost"},"children":[]},{"data":{"id":"d3ekccc9igow","created":1723529854094,"text":"下级任务genome_assembly"},"children":[]}]}]},{"data":{"id":"d3ekcjv6qayo","created":1723529870475,"text":"Steps4.metagenome assembly\n step1:assemble【二、三代区别】"},"children":[{"data":{"id":"d3ekcod5q328","created":1723529880269,"text":"二代组装"},"children":[{"data":{"id":"d3ekd1c7x62o","created":1723529908510,"text":"调用脚本：metaG_main_pipeline/assembly_cwl.py"},"children":[]},{"data":{"id":"d3ekd5cu4000","created":1723529917255,"text":"id: genome_assembly"},"children":[]},{"data":{"id":"d3ekd8ed57gg","created":1723529923878,"text":"脚本用途"},"children":[{"data":{"id":"d3ekdboq7da8","created":1723529931035,"text":"1.从项目配置文件detail.cfg获得组装的方法assembly_method，从脚本汇总文件script.cfg获得组装软件的路径；"},"children":[]},{"data":{"id":"d3ekl64lo8ow","created":1723530545847,"text":"2.组装软件有两种选择：megahit和idba_ud；"},"children":[]},{"data":{"id":"d3ekl7nnfev4","created":1723530549176,"text":"若选择megahit的参数如下：\nmegahit -f【强制运行模式】 -t 6 -1 输入fq1 -2 输入fq2 -o 组装结果路径【outputs/samplename_assemble】 --out-prefix 输出文件前缀samplename\n --k-list 参数可选normal和meta_large【指定 k-mer 长度的列表【'normal': '27,37,47,69,93,121'、'meta_large': '31,41,51,75,103'】\n如果上一步中cleandata的数据量超过一半>11G选meta_large】；然后将组装好的contigs.fa文件处理成contigs.fasta"},"children":[]},{"data":{"id":"d3ekldcyc2rk","created":1723530561590,"text":"若选择idba_ud需要先将数据解压，将fq转成fa：\n/share/nas2/genome/biosoft/idba/1.1.1/bin/fq2fa --merge --filter 输入fq1 输入fq2 输出文件samplename.fa\n读一条序列的长度，如果>300的组装参数如下：\n/share/nas2/genome/biosoft/idba/1.1.1/bin/idba_ud -r 输入fa文件【-r长度是小于300】 --out 输出文件fa --num_threads 6 --pre_correction【组装前进行预校正】\n如果<300的组装参数如下：\nidba_ud -l 输入fa文件【-l长度是大于300】 --out 输出文件fa --num_threads 6 --pre_correction【组装前进行预校正】\n然后将组装好的contigs.fa文件处理成contigs.fasta"},"children":[]}]},{"data":{"id":"d3eklotucvls","created":1723530586555,"text":"输出文件夹：genome_assembly_*"},"children":[]},{"data":{"id":"d3ekpyryfzeo","created":1723530921666,"text":"比对的算法原理"},"children":[{"data":{"id":"d3ekstwpcr28","created":1723531146161,"text":"算法"},"children":[{"data":{"id":"d3ekswklj280","created":1723531151960,"text":"拼接 (Greedy) 算法：如 ABySS 和 ALLPATHS-LG，通过贪婪方式逐步拼接短读长数据。"},"children":[]},{"data":{"id":"d3ektpka1ngg","created":1723531215067,"text":"Overlap-Layout-Consensus (OLC) 算法：如 Canu 和 Celera Assembler，通过重叠对齐短读长数据并生成共识序列。"},"children":[]},{"data":{"id":"d3ekuej6t62o","created":1723531269421,"text":"De Bruijn 图算法(DBG)：如 SOAPdenovo、Velvet 和【 IDBA-UD】、【MEGAHIT 】，利用 De Bruijn 图来处理短读长数据。"},"children":[]}]},{"data":{"id":"d3el5texibk0","created":1723532163822,"text":"DBG算法原理"},"children":[{"data":{"id":"d3el668mzhts","created":1723532191739,"text":"步骤","expandState":"expand"},"children":[{"data":{"id":"d3el68el0kqo","created":1723532196452,"text":"reads Kmer化和纠错：将reads进行Kmer化，若由于测序错误有一个错误的碱基那么在得到的Kmer中，\n也会有一些错误Kmer或者低频Kmer，错误Kmer对后续组装会产生很大的困扰，因此会在构建DBG之前过滤掉低频Kmer"},"children":[]},{"data":{"id":"d3eldt3ejdvk","created":1723532790037,"text":"构建 de Brujin算图：根据Kmer之间的overlap关系进行连接，构建DBG"},"children":[]},{"data":{"id":"d3elf8xvhpmo","created":1723532902896,"text":"DBG简化：简化DBG需要去掉无法继续连接的分支、低覆盖度的分支，通常需要考虑如下几种情况：A.由于测序错误形成的低频Kmer，直接删除；\nB.通过短序列将一些很短的重复解开；C.如果Kmer1和Kmer2有很高的相似性，将形成的泡状结构合并；"},"children":[]},{"data":{"id":"d3elhjvcf4sg","created":1723533083416,"text":"Contig：在简化图的基础上，仍然会因有很多分叉位点无法确定真正的连接关系，因此接下来在每个分叉位点将序列截断，得到了最初contigs。"},"children":[]}]},{"data":{"id":"d3eli584du68","created":1723533129901,"text":"算法特点"},"children":[{"data":{"id":"d3elian6l79c","created":1723533141695,"text":"有纠错过程，结果错误率低，内存消耗相对较低，运行速度快。"},"children":[]}]}]}]}]},{"data":{"id":"d3ekcy9ldqf4","created":1723529901821,"text":"ONT组装"},"children":[{"data":{"id":"d3ekm0lg9csg","created":1723530612169,"text":"调用脚本：nanopore_assembly.py"},"children":[]},{"data":{"id":"d3ekmad29fy8","created":1723530633430,"text":"脚本用途"},"children":[{"data":{"id":"d3ekmmah5log","created":1723530659395,"text":"1.从script.cfg配置文件中读入flye软件以及flye环境变量"},"children":[]},{"data":{"id":"d3ekmsuxvbwg","created":1723530673693,"text":"2.三代全长组装只有flye软件可选；组装参数：flye --nano-raw cleanfq --meta【meta模式，序列会更加的片段化】 --out-dir output\n -i 1【只进行一次polish，进行多次polish会矫正更多的错误】","layout_right_offset":{"x":1,"y":10}},"children":[]}]},{"data":{"id":"d3ekncr1qzgg","created":1723530716993,"text":"比对软件","layout_right_offset":{"x":0,"y":3}},"children":[{"data":{"id":"d3ellpyfcvsw","created":1723533410119,"text":"前端可选"},"children":[{"data":{"id":"d3elm2714vls","created":1723533436761,"text":"Canu"},"children":[{"data":{"id":"d3elzcfpoxds","created":1723534477788,"text":"Canu是基于OLC算法，具有长reads的自纠错和组装功能，是应用最为广泛的三代组装软件"},"children":[]}]},{"data":{"id":"d3elm8pqyxvk","created":1723533450953,"text":"Miniasm"},"children":[]}]},{"data":{"id":"d3ellu4aiscg","created":1723533419181,"text":"后端"},"children":[{"data":{"id":"d3elme3jhon4","created":1723533462671,"text":"flye"},"children":[{"data":{"id":"d3elw2l6u48w","created":1723534221259,"text":"19年发表在Nature Biotechnology"},"children":[]},{"data":{"id":"d3elu6xllc00","created":1723534073988,"text":"Flye算法使用repeat graph作为核心的数据结构，不同于de bruijn图需要精确的kmer的匹配，repeat graph可以构建相似的序列匹配，从而可以容忍较高的噪音。"},"children":[]},{"data":{"id":"d3eluq76l534","created":1723534115926,"text":"repeat graph的边代表基因组序列，顶点代表连接情况。所有的边要么是唯一的 ，要么是重复的。通过遍历这个repeat graph可以得到整个基因组。因此unique的graph是只在遍历中出现一次。"},"children":[]}]}]}]}]}]},{"data":{"id":"d3eljmv5pyio","created":1723533246663,"text":"Steps4.metagenome assembly step2:assemble length filter"},"children":[]}]},"template":"right","theme":"fresh-green-compat","version":"1.4.43"}