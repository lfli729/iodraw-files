{"root":{"data":{"id":"d3ejy2qfdyio","created":1723528736084,"text":"2.组装"},"children":[{"data":{"id":"d3ekb9h8sl4w","created":1723529769500,"text":"Steps4.metagenome assembly\n step0: preparation【三代无】"},"children":[{"data":{"id":"d3ekbfe3vthc","created":1723529782371,"text":"调用脚本：metaG_main_pipeline/genome_assembly_preparation.py"},"children":[]},{"data":{"id":"d3ekbiely5mo","created":1723529788932,"text":"id: genome_assembly_preparation_cleanData"},"children":[]},{"data":{"id":"d3ekblbdbthc","created":1723529795266,"text":"脚本用途"},"children":[{"data":{"id":"d3ekbo5m0mww","created":1723529801449,"text":"1.读入去宿主后的fq序列，读入脚本配置文件获取seqkit的路径；"},"children":[]},{"data":{"id":"d3ekbsi7d0cg","created":1723529810917,"text":"2.使用seqkit stats统计每个fastq的总序列数、总碱基数、最长序列长度、最短序列长度、平均序列长度等。"},"children":[]},{"data":{"id":"d3ekbwn4w4xs","created":1723529819922,"text":"3.同时会在结果路径cleanData下生成cleanData.baseNum文件记录每个序列的碱基数目。"},"children":[]}]},{"data":{"id":"d3ekc13ah728","created":1723529829606,"text":"输出文件夹：genome_assembly_preparation_cleanData_*"},"children":[]},{"data":{"id":"d3ekc88as6bk","created":1723529845147,"text":"任务关联"},"children":[{"data":{"id":"d3ekc966fda8","created":1723529847195,"text":"上级任务data_process_rmhost"},"children":[]},{"data":{"id":"d3ekccc9igow","created":1723529854094,"text":"下级任务genome_assembly"},"children":[]}]}]},{"data":{"id":"d3ekcjv6qayo","created":1723529870475,"text":"Steps4.metagenome assembly\n step1:assemble【二、三代区别】"},"children":[{"data":{"id":"d3ekcod5q328","created":1723529880269,"text":"二代组装"},"children":[{"data":{"id":"d3ekd1c7x62o","created":1723529908510,"text":"调用脚本：metaG_main_pipeline/assembly_cwl.py"},"children":[]},{"data":{"id":"d3ekd5cu4000","created":1723529917255,"text":"id: genome_assembly"},"children":[]},{"data":{"id":"d3ekd8ed57gg","created":1723529923878,"text":"脚本用途"},"children":[{"data":{"id":"d3ekdboq7da8","created":1723529931035,"text":"1.从项目配置文件detail.cfg获得组装的方法assembly_method，从脚本汇总文件script.cfg获得组装软件的路径；"},"children":[]},{"data":{"id":"d3ekl64lo8ow","created":1723530545847,"text":"2.组装软件有两种选择：megahit和idba_ud；"},"children":[]},{"data":{"id":"d3ekl7nnfev4","created":1723530549176,"text":"若选择megahit的参数如下：\nmegahit -f【强制运行模式】 -t 6 -1 输入fq1 -2 输入fq2 -o 组装结果路径【outputs/samplename_assemble】 --out-prefix 输出文件前缀samplename\n --k-list 参数可选normal和meta_large【指定 k-mer 长度的列表【'normal': '27,37,47,69,93,121'、'meta_large': '31,41,51,75,103'】\n如果上一步中cleandata的数据量超过一半>11G选meta_large】；然后将组装好的contigs.fa文件处理成contigs.fasta"},"children":[]},{"data":{"id":"d3ekldcyc2rk","created":1723530561590,"text":"若选择idba_ud需要先将数据解压，将fq转成fa：\n/share/nas2/genome/biosoft/idba/1.1.1/bin/fq2fa --merge --filter 输入fq1 输入fq2 输出文件samplename.fa\n读一条序列的长度，如果>300的组装参数如下：\n/share/nas2/genome/biosoft/idba/1.1.1/bin/idba_ud -r 输入fa文件【-r长度是小于300】 --out 输出文件fa --num_threads 6 --pre_correction【组装前进行预校正】\n如果<300的组装参数如下：\nidba_ud -l 输入fa文件【-l长度是大于300】 --out 输出文件fa --num_threads 6 --pre_correction【组装前进行预校正】\n然后将组装好的contigs.fa文件处理成contigs.fasta"},"children":[]}]},{"data":{"id":"d3eklotucvls","created":1723530586555,"text":"输出文件夹：genome_assembly_*"},"children":[]},{"data":{"id":"d3ekpyryfzeo","created":1723530921666,"text":"比对的算法原理"},"children":[{"data":{"id":"d3ekstwpcr28","created":1723531146161,"text":"算法"},"children":[{"data":{"id":"d3ekswklj280","created":1723531151960,"text":"拼接 (Greedy) 算法：如 ABySS 和 ALLPATHS-LG，通过贪婪方式逐步拼接短读长数据。"},"children":[]},{"data":{"id":"d3ektpka1ngg","created":1723531215067,"text":"Overlap-Layout-Consensus (OLC) 算法：如 Canu 和 Celera Assembler，通过重叠对齐短读长数据并生成共识序列。"},"children":[]},{"data":{"id":"d3ekuej6t62o","created":1723531269421,"text":"De Bruijn 图算法(DBG)：如 SOAPdenovo、Velvet 和【 IDBA-UD】、【MEGAHIT 】，利用 De Bruijn 图来处理短读长数据。"},"children":[]}]},{"data":{"id":"d3el5texibk0","created":1723532163822,"text":"DBG算法原理"},"children":[{"data":{"id":"d3el668mzhts","created":1723532191739,"text":"步骤","expandState":"expand"},"children":[{"data":{"id":"d3el68el0kqo","created":1723532196452,"text":"reads Kmer化和纠错：将reads进行Kmer化，若由于测序错误有一个错误的碱基那么在得到的Kmer中，\n也会有一些错误Kmer或者低频Kmer，错误Kmer对后续组装会产生很大的困扰，因此会在构建DBG之前过滤掉低频Kmer"},"children":[]},{"data":{"id":"d3eldt3ejdvk","created":1723532790037,"text":"构建 de Brujin算图：根据Kmer之间的overlap关系进行连接，构建DBG"},"children":[]},{"data":{"id":"d3elf8xvhpmo","created":1723532902896,"text":"DBG简化：简化DBG需要去掉无法继续连接的分支、低覆盖度的分支，通常需要考虑如下几种情况：A.由于测序错误形成的低频Kmer，直接删除；\nB.通过短序列将一些很短的重复解开；C.如果Kmer1和Kmer2有很高的相似性，将形成的泡状结构合并；"},"children":[]},{"data":{"id":"d3elhjvcf4sg","created":1723533083416,"text":"Contig：在简化图的基础上，仍然会因有很多分叉位点无法确定真正的连接关系，因此接下来在每个分叉位点将序列截断，得到了最初contigs。"},"children":[]}]},{"data":{"id":"d3eli584du68","created":1723533129901,"text":"算法特点"},"children":[{"data":{"id":"d3elian6l79c","created":1723533141695,"text":"有纠错过程，结果错误率低，内存消耗相对较低，运行速度快。"},"children":[]}]}]}]},{"data":{"id":"d3eo7bgvyd4w","created":1723540744815,"text":"Steps4.metagenome assembly\nstep2:assemble length filter"},"children":[{"data":{"id":"d3eo7e4rup6o","created":1723540750613,"text":"调用脚本：metaG_main_pipeline/assembly_length_filter.py"},"children":[]},{"data":{"id":"d3eo7pkuw9vk","created":1723540775530,"text":"脚本用途"},"children":[{"data":{"id":"d3eo7stytatc","created":1723540782611,"text":"1.读项目的配置文件detail.cfg获得mininum_contig最短contig长度阈值；"},"children":[]},{"data":{"id":"d3eo7u2iqp6o","created":1723540785305,"text":"2.从脚本汇总文件script.cfg获得长度过滤软件fasta_filter_by_length的路径；"},"children":[]},{"data":{"id":"d3eo7zqar9c0","created":1723540797627,"text":"3.根据最短长度阈值进行过滤，一般阈值是300。"},"children":[]}]}]}]},{"data":{"id":"d3ekcy9ldqf4","created":1723529901821,"text":"ONT组装"},"children":[{"data":{"id":"d3enoe65ikg0","created":1723539261778,"text":"基因组组装"},"children":[{"data":{"id":"d3ekm0lg9csg","created":1723530612169,"text":"调用脚本：nanopore_assembly.py"},"children":[]},{"data":{"id":"d3ekmad29fy8","created":1723530633430,"text":"脚本用途"},"children":[{"data":{"id":"d3ekmmah5log","created":1723530659395,"text":"1.从script.cfg配置文件中读入flye软件以及flye环境变量"},"children":[]},{"data":{"id":"d3ekmsuxvbwg","created":1723530673693,"text":"2.三代全长组装只有flye软件可选；组装参数：flye --nano-raw cleanfq --meta【meta模式，序列会更加的片段化】 --out-dir output\n -i 1【只进行一次polish，进行多次polish会矫正更多的错误】"},"children":[]}]},{"data":{"id":"d3ekncr1qzgg","created":1723530716993,"text":"比对软件"},"children":[{"data":{"id":"d3ellpyfcvsw","created":1723533410119,"text":"前端可选"},"children":[{"data":{"id":"d3elm2714vls","created":1723533436761,"text":"Canu"},"children":[{"data":{"id":"d3elw2l6u48w","created":1723534221259,"text":"17年发表在Genome Research"},"children":[]},{"data":{"id":"d3elzcfpoxds","created":1723534477788,"text":"Canu是基于OLC算法，具有长reads的自纠错和组装功能，是应用最为广泛的三代组装软件"},"children":[]},{"data":{"id":"d3em1sczvxfk","created":1723534669180,"text":"Canu对pacbio和nanopore原始数据的组装分为三个步骤：纠错，修整和组装。"},"children":[]},{"data":{"id":"d3em28h1k4jk","created":1723534704254,"text":"每一步经历以下几个步骤：1.加载read到read数据库（seqStore）；2.进行k-mer计数；3.计算overlap，加载到数据库（OvlStore）；4.根据overlap进行纠错/修剪/组装"},"children":[]}]},{"data":{"id":"d3elm8pqyxvk","created":1723533450953,"text":"Miniasm"},"children":[{"data":{"id":"d3em8flxrojk","created":1723535189972,"text":"16年发表在Bioinformatics"},"children":[]},{"data":{"id":"d3em8ke1416o","created":1723535200378,"text":"Miniasm是基于OLC算法的组装软件，适用于长reads序列"},"children":[]}]}]},{"data":{"id":"d3ellu4aiscg","created":1723533419181,"text":"后端"},"children":[{"data":{"id":"d3elme3jhon4","created":1723533462671,"text":"flye"},"children":[{"data":{"id":"d3elw2l6u48w","created":1723534221259,"text":"19年发表在Nature Biotechnology"},"children":[]},{"data":{"id":"d3elu6xllc00","created":1723534073988,"text":"Flye算法使用repeat graph作为核心的数据结构，不同于de bruijn图需要精确的kmer的匹配，repeat graph可以构建相似的序列匹配，从而可以容忍较高的噪音。"},"children":[]},{"data":{"id":"d3eluq76l534","created":1723534115926,"text":"repeat graph的边代表基因组序列，顶点代表连接情况。所有的边要么是唯一的 ，要么是重复的。通过遍历这个repeat graph可以得到整个基因组。因此unique的graph是只在遍历中出现一次。"},"children":[]}]}]}]}]},{"data":{"id":"d3enp7fzzpxc","created":1723539325499,"text":"挑选高质量contigs"},"children":[{"data":{"id":"d3enppidxs74","created":1723539364826,"text":"调用脚本：depth_flat.py"},"children":[]},{"data":{"id":"d3enq6x5r0g0","created":1723539402724,"text":"脚本用途"},"children":[{"data":{"id":"d3enqbs20mbk","created":1723539413300,"text":"1.组装的contig作为ref基因组使用minimap2建索引；"},"children":[]},{"data":{"id":"d3enqfrr8lxc","created":1723539421989,"text":"2.使用测序的数据对构建的索引进行比对得到sam文件，使用samtools统计深度和覆盖度；"},"children":[]},{"data":{"id":"d3enqh5qvk74","created":1723539425011,"text":"3.使用pick_reads.py挑选深度>30的高质量组装contigs。"},"children":[]}]}]},{"data":{"id":"d3eo1vif0ykg","created":1723540318258,"text":"组装结果校正"},"children":[{"data":{"id":"d3eo1wyyye4g","created":1723540321436,"text":"调用脚本：polish.py"},"children":[]},{"data":{"id":"d3eo2g5l9s00","created":1723540363195,"text":"脚本用途"},"children":[{"data":{"id":"d3eo2kjiab5s","created":1723540372744,"text":"使用Racon进行组装结果校正，Racon 需要两个主要输入：a.组装的基因组序列（通常是由短读长数据构建的初步组装结果）;b.高质量的长读长数据（用于校正组装结果：上一步根据深度挑选的序列）"},"children":[]},{"data":{"id":"d3eo2ocn2eww","created":1723540381036,"text":"使用比对工具（如 minimap2 或 BWA）将长读长数据比对到初步组装的基因组序列上，会进行3次迭代校正。"},"children":[]},{"data":{"id":"d3eo34yzvo5c","created":1723540417216,"text":"ONT的宏基因组再使用Medaka对Racon的结果使用深度学习模型的方式进行1次迭代校正，改善基因组组装过程中的错误修正，提高组装质量。"},"children":[]}]}]}]},{"data":{"id":"d3h7ivte0tmo","created":1723798372114,"text":"组装以及过滤后：会得到组装好并经过长度过滤的contigs.fasta序列文件","progress":9},"children":[]}]},{"data":{"id":"d3eljmv5pyio","created":1723533246663,"text":"Steps4.metagenome assembly \nstep2:assemble coverage and length"},"children":[{"data":{"id":"d3eo92y9z280","created":1723540883004,"text":"二代"},"children":[{"data":{"id":"d3eo9f9wtyio","created":1723540909829,"text":"调用脚本：metaG_main_pipeline/assembly_coverage_length.py"},"children":[]},{"data":{"id":"d3eoa2tras5c","created":1723540961095,"text":"id: genome_assembly_coverage_length"},"children":[]},{"data":{"id":"d3eob35ub9q8","created":1723541040190,"text":"脚本用途"},"children":[{"data":{"id":"d3eoc1u89tds","created":1723541115675,"text":"1.组装好的序列经过长度过滤的 fa 建bwa索引"},"children":[]},{"data":{"id":"d3eobfxadtkw","created":1723541067971,"text":"2.bwa mem 算法进行序列比对得到sam文件"},"children":[]},{"data":{"id":"d3eocp5mmxog","created":1723541166430,"text":"3.samtools统计深度和覆盖度等信息，并画长度分布图。"},"children":[]}]}]},{"data":{"id":"d3eo95gx6yv4","created":1723540888485,"text":"三代"},"children":[{"data":{"id":"d3eoaglcbaww","created":1723540991061,"text":"调用脚本：assembly_coverage_length.py"},"children":[]},{"data":{"id":"d3eoahnudr0g","created":1723540993389,"text":"脚本用途"},"children":[{"data":{"id":"d3eoalgp9hj4","created":1723541001664,"text":"1.对组装的contigs按照特定长度进行筛选；"},"children":[]},{"data":{"id":"d3eoaqkhderk","created":1723541012777,"text":"2.cleandata使用minimap2比对筛选的contigs序列得到sam文件；"},"children":[]},{"data":{"id":"d3eoawnz2m0w","created":1723541026049,"text":"3.samtools统计深度和覆盖度等信息，并画长度分布图。"},"children":[]}]}]}]},{"data":{"id":"d3eodd6erif4","created":1723541218720,"text":"Steps4.metagenome assembly \nstep2:stat"},"children":[{"data":{"id":"d3eodgtlwhz4","created":1723541226653,"text":"Quast软件评估基因组组装质量，汇总：总序列长度、最长contig长度、N50、GC含量、比对率等基本的组装信息。"},"children":[]}]},{"data":{"id":"d3eoe9oj0l4w","created":1723541289473,"text":"Steps4.metagenome assembly \nstep3 backup"},"children":[{"data":{"id":"d3eoeqfzqoe8","created":1723541325962,"text":"使用zip -rq 压缩结果。"},"children":[]}]}]},"template":"right","theme":"fresh-green-compat","version":"1.4.43"}